\subsubsection*{Reasoning about Program Properties}

To analyze properties of a program, we use Boolean formulas with free meta-variables that combine facts that must hold globally or at certain points of a program. Formulas can be checked against concrete programs by a {\em model checker}. For any program $\pi$ and formula $\phi$, the checker verifies if there exists a substitution $\theta$ that binds free meta-variables with program objects so that $\theta(\phi)$ is satisfied in $\pi$. 
In this paper, by $\cal{A}\models \phi$ we mean that $\phi$ is true in $\cal{A}$, i.e., formula $\phi$ is satisfied by structure $\cal{A}$ (or equivalently, $\cal{A}$ models $\phi$)~\cite{Clarke86}. %We use notation $\cal{A}\models_{\theta} \phi$ as a shortcut for $\cal{A}\models \theta(\phi)$. 

Two global predicates that we will use later on are ${\tt conlit}(\wc)$, which states that an expression $\wc$ is a constant literal, and ${\tt freevar}(\wx,\we)$, which holds if and only if $\wx$ is a free variable of expression $\we$.

To support analyses based on facts that involve finite maximal paths in the control flow graph (CFG), such as liveness and dominance, we use formulas based on {\em computation tree logic} (CTL) operators~\cite{Clarke86,Lacey04,Kalvala09}. In order to introduce these operators, we need to formalize the concept of finite maximal paths first.

\begin{definition}[Set of Complete Paths] Given a control flow graph $G=(V,E)$ and an initial node $n_0\in V$, the {\em set of complete paths} $CPaths(n_0,G)$ starting at $n_0$ consists of all finite sequences $\langle n_0,n_1,\ldots,n_k\rangle$ such that $(n_i,n_{i+1})\in E$ for all $n_i$ with $i<k$, and such that there does not exist a $n_{k+1}$ such that $(n_k,n_{k+1})\in E$.
\end{definition}

\noindent Complete paths from a specified node (i.e., instruction) are thus maximal finite sequences of connected nodes through a control flow graph from an initial point to a sink node, which in our setting is unique (unless {\tt abort} instructions are present) and corresponds to the final instruction $I_n$.

First-order CTL can be used to specify properties of nodes and paths in a CFG. In particular, temporal CTL operators can be used to express properties of some or all possible future computational paths, any one of which might be an actual path that is realized. Before formalizing the temporal operators that we are going to use in the remainder of this chapter, we provide an intuitive definition for them. We say that, given a point $l$ in a program $\pi$ and two formulas $\phi$ and $\psi$, the following predicates are satisfied at $l$ if:

\begin{itemize}[parsep=0pt,topsep=3pt]
\item $\overrightarrow{AX}(\phi)$: $\phi$ holds for all immediate successors of $l$;
\item $\overrightarrow{EX}(\phi)$: $\phi$ holds for at least one immediate successor of $l$;
\item $\overrightarrow{A}(\phi~U~\psi)$: $\phi$ holds on all paths from $l$, until $\psi$ holds;
\item $\overrightarrow{E}(\phi~U~\psi)$: $\phi$ holds on at least one path from $l$, until $\psi$ holds.
\end{itemize}
\noindent Corresponding operators $\overleftarrow{AX}$ and $\overleftarrow{EX}$ are defined for immediate predecessors of $l$, while $\overleftarrow{A}$ and $\overleftarrow{E}$ refer to backward paths from $l$.

\begin{example}
 \missing
\end{example}

%\begin{definition}[Until Predicate]
%Given a node $n_0$ in the control flow graph $G$ and a path $p = \langle n_0,n_1,\ldots,n_k\rangle \in CPaths(n_0,G)$, we say that the predicate {\em Until}$(p,\phi,\psi)$ holds if:
%\begin{equation*}
%\exists j: 0 \le j\le k: n_j \models \psi \; \wedge \forall 0 \le i < j: n_i \models \phi
%\end{equation*}
%\end{definition}

\begin{definition}[Temporal Operators]
Given a node $n$ in the control flow graph $G=(V,E)$ of a program $\pi$, we define the following CTL {\em temporal operators} as:

\begin{equation*}
\begin{align}
n \models \overrightarrow{AX}(\phi) &\Longleftrightarrow \forall m: (n,m)\in E: \pi,m\models\phi \\
n \models \overrightarrow{EX}(\phi) &\Longleftrightarrow \exists m: (n,m)\in E: \pi, m\models\phi \\
n \models \overrightarrow{A}(\phi~U~\psi) &\Longleftrightarrow \forall p: p\in CPaths(n,G): Until(\pi, p,\phi,\psi) \\
n \models \overrightarrow{E}(\phi~U~\psi) &\Longleftrightarrow \exists p: p\in CPaths(n,G): Until(\pi, p,\phi,\psi) \\
\end{align}
\end{equation*}

\vspace{0.5em}
\noindent where predicate $Until(\pi,p,\phi,\psi)$ holds for $p = \langle n_0,n_1,\ldots,n_k\rangle \in CPaths(n_0,G)$ if:
\vspace{-0.5em}

\begin{equation*}
\exists j: 0 \le j\le k: \pi, n_j \models \psi \; \wedge \: \forall 0 \le i < j: \pi, n_i \models \phi
\end{equation*}

\noindent Operators $\overleftarrow{AX}$, $\overleftarrow{EX}$, $\overleftarrow{A}$, and $\overleftarrow{E}$ can be defined similarly on the reverse control flow graph $\overleftarrow{G}$, which is identical to $G$ but with every edge in $\overleftarrow{E}$ flipped.
\end{definition}

\noindent Operators $A$ and $E$ are quantifiers over paths, while $X$ and $U$ path-specific quantifiers. Notice that $\phi~U~\psi$ requires that $\phi$ as to hold at least until at some node $\psi$ is satisfied: this implies that $\psi$ will be verified in the future.

\begin{figure}[hb]
\vspace{-3mm}
\begin{small}
\begin{eqnarray*}
\wdef(\wx) & \triangleq & I_l= \texttt{x:=e} ~~ \vee ~~ I_l= \texttt{in} ~ \cdots ~ \texttt{x} \cdots \\
%                            &            & I_l= \texttt{in} ~ \cdots ~ \texttt{x} \cdots \\
                            &            & [\wx ~ \textit{is defined by instruction} ~ I_l ~ \textit{in} ~ \pi] \\
\wuse(\wx) & \triangleq & I_l= \texttt{y:=e[x]} ~ \vee  \\
                            &            & I_l= \texttt{if (e[x]) goto m} ~ \vee \ \\
                            &            & I_l= \texttt{out} ~ \cdots ~ \texttt{x} \cdots \\
                            &            & [\wx ~ \textit{is used by instruction} ~ I_l ~ \textit{in} ~ \pi] \\
\wtrans(\we) & \triangleq & I_l= \texttt{x:=e'} ~ \wedge ~ \neg\wfreevar(\wx,\we) ~ \vee \\
                            &            & I_l\neq\texttt{x:=e'} \\
                            &            & [\we ~ \textit{is not affected by instruction} ~ I_l ~ \textit{in} ~ \pi] \\
\live(\wx) & \triangleq & \overleftarrow{AX}\overleftarrow{A}(\text{true} ~ U ~ \wdef(\wx)) ~ \wedge \\
                            &            & \overrightarrow{E}(\neg\wdef(\wx) ~ U ~ \wuse(\wx)) \\
                            &            & [\wx ~ \textit{is live at program point} ~ l ~ \textit{in} ~ \pi] \\
\ureachdef(\wx,l') & \triangleq & \wdef(\wx)\wedge\overrightarrow{AX}\overrightarrow{A}(\neg\wdef(\wx) ~ U ~ \point(l')) \\
                            &            & [\textit{unique definition of}~\wx~{at}~l~\textit{reaching}~l'~\textit{in} ~ \pi] \\
\stmt(I) & \triangleq & I=I_l ~~~ [I ~ \textit{is the instruction at} ~ l ~ \textit{in} ~ \pi]\\
%                 &            & [I ~ \textit{is the instruction at} ~ l ~ \textit{in} ~ \pi] \\
\point(\texttt{m}) & \triangleq & \texttt{m}=l ~~~ [\textit{program point} ~ \wm ~ \textit{is} ~ l ~ \textit{in} ~ \pi]
%                           &            & [\textit{program point} ~ \wm ~ \textit{is} ~ l ~ \textit{in} ~ \pi]
\end{eqnarray*}
\vspace{-4mm}
\end{small}
\caption{\label{fig:osr-loc-pred}Predicates expressing local properties of a point $l\in [1,n]$ in a program $\pi=\langle I_1,\ldots,I_n\rangle$, with meta-variables $\texttt{e},\texttt{e'}\in Expr$, $\texttt{x}, \texttt{y}\in Var$, and $l, \texttt{m}\in Num$.}
\end{figure}

\myfigure\ref{fig:osr-loc-pred} shows a number of local predicates that will be useful throughout the paper. For instance, $\pi,l\models \ureachdef(\wx, l')$ ({\em unique reaching definition}) holds if and only if variable $\wx$ is defined at $l$ and on all paths in the control flow graph starting from an immediate successor of $l$, $\wx$ is not redefined until point $l'$ is reached, i.e., there is a unique definition of $\wx$ that reaches $l'$, and this definition is at $l$. The following definition will be useful, too:

\begin{definition}[Live Variables]
\label{de:live-var}
The set of live variables of a program $\pi$ at point $l$ is defined as:
\vspace{-1mm}
\begin{equation*}
\live(\pi,l) \triangleq \{ ~ \wx\in Var ~ | ~ \pi, l\models \live(\wx) ~ \}
\end{equation*}
\end{definition}